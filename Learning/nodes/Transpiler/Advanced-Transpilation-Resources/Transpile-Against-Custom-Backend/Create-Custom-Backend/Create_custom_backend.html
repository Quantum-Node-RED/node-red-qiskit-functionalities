
<script type="text/javascript">
    RED.nodes.registerType("create-custom-backend", {
      category: "Transpile against custom backend",
      color: "#dddddd",
      defaults: {
        name: { value: "Create a Custom Backend" },
        info: { value: "# The <font style=\"background: lightgrey\">BackendV2</font> object is an abstract class used for all backend objects created by a provider (either within <font style=\"background: lightgrey\">qiskit.providers</font> or another library such as [<font style=\"background: lightgrey\">qiskit_ibm_runtime.IBMBackend</font>](https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.IBMBackend)). As mentioned above, these objects contain several attributes, including a <font style=\"background: lightgrey\">Target</font>. The <font style=\"background: lightgrey\">Target</font> contains information that specifies the backend's attributes - such as the [<font style=\"background: lightgrey\">Coupling Map</font>](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.CouplingMap), list of [<font style=\"background: lightgrey\">Instructions</font>](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.Instruction), and others - to the transpiler. In addition to the Target, one can also define pulse-level details such as the [<font style=\"background: lightgrey\">DriveChannel</font>](https://docs.quantum.ibm.com/api/qiskit/qiskit.pulse.channels.DriveChannel) or [<font style=\"background: lightgrey\">ControlChannel</font>](https://docs.quantum.ibm.com/api/qiskit/qiskit.pulse.channels.ControlChannel).\r\n&nbsp;\r\n# The following example demonstrates this customization by creating a simulated multi-chip backend, where each chip possesses a heavy-hex connectivity. The example specifies the backend's two-qubit gate set to be [<font style=\"background: lightgrey\">CZGates</font>](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.CZGate) within each chip and [<font style=\"background: lightgrey\">CXGates</font>](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.ECRGate) between chips. First, create your own <font style=\"background: lightgrey\">BackendV2</font> and customize its <font style=\"background: lightgrey\">Target</font> with single and two-qubit gates according to the previously described constraints.\r\n```python\r\nimport numpy as np\r\nimport rustworkx as rx\r\n \r\nfrom qiskit.providers import BackendV2, Options\r\nfrom qiskit.transpiler import Target, InstructionProperties\r\nfrom qiskit.circuit.library import XGate, SXGate, RZGate, CZGate, ECRGate\r\nfrom qiskit.circuit import Measure, Delay, Parameter, IfElseOp, Reset\r\nfrom qiskit import QuantumCircuit, transpile\r\nfrom qiskit.visualization import plot_gate_map, plot_coupling_map\r\n \r\n \r\n \r\nclass FakeLOCCBackend(BackendV2):\r\n    \"\"\"Fake multi chip backend.\"\"\"\r\n \r\n    def __init__(self, distance=3, number_of_chips=3):\r\n        \"\"\"Instantiate a new fake multi chip backend.\r\n \r\n        Args:\r\n            distance (int): The heavy hex code distance to use for each chips'\r\n                coupling map. This number **must** be odd. The distance relates\r\n                to the number of qubits by:\r\n                :math:`n = \\\\frac{5d^2 - 2d - 1}{2}` where :math:`n` is the\r\n                number of qubits and :math:`d` is the ``distance``\r\n            number_of_chips (int): The number of chips to have in the multichip backend\r\n                each chip will be a heavy hex graph of ``distance`` code distance.\r\n        \"\"\"\r\n        super().__init__(name='Fake LOCC backend')\r\n        # Create a heavy-hex graph using the rustworkx library, then instantiate a new target\r\n        self._graph = rx.generators.directed_heavy_hex_graph(distance, bidirectional=False)\r\n        num_qubits = len(self._graph) * number_of_chips\r\n        self._target = Target(\"Fake multi-chip backend\", num_qubits=num_qubits)\r\n \r\n        # Generate instruction properties for single qubit gates and a measurement, delay,\r\n        #  and reset operation to every qubit in the backend.\r\n        rng = np.random.default_rng(seed=12345678942)\r\n        rz_props = {}\r\n        x_props = {}\r\n        sx_props = {}\r\n        measure_props = {}\r\n        delay_props = {}\r\n \r\n        # Add 1q gates. Globally use virtual rz, x, sx, and measure\r\n        for i in range(num_qubits):\r\n            qarg = (i,)\r\n            rz_props[qarg] = InstructionProperties(error=0.0, duration=0.0)\r\n            x_props[qarg] = InstructionProperties(\r\n                error=rng.uniform(1e-6, 1e-4), duration=rng.uniform(1e-8, 9e-7)\r\n            )\r\n            sx_props[qarg] = InstructionProperties(\r\n                error=rng.uniform(1e-6, 1e-4), duration=rng.uniform(1e-8, 9e-7)\r\n            )\r\n            measure_props[qarg] = InstructionProperties(\r\n                error=rng.uniform(1e-3, 1e-1), duration=rng.uniform(1e-8, 9e-7)\r\n            )\r\n            delay_props[qarg] = None\r\n        self._target.add_instruction(XGate(), x_props)\r\n        self._target.add_instruction(SXGate(), sx_props)\r\n        self._target.add_instruction(RZGate(Parameter(\"theta\")), rz_props)\r\n        self._target.add_instruction(Measure(), measure_props)\r\n        self._target.add_instruction(Reset(), measure_props)\r\n \r\n        self._target.add_instruction(Delay(Parameter(\"t\")), delay_props)\r\n        # Add chip local 2q gate which is CZ\r\n        cz_props = {}\r\n        for i in range(number_of_chips):\r\n            for root_edge in self._graph.edge_list():\r\n                offset = i * len(self._graph)\r\n                edge = (root_edge[0] + offset, root_edge[1] + offset)\r\n                cz_props[edge] = InstructionProperties(\r\n                    error=rng.uniform(7e-4, 5e-3), duration=rng.uniform(1e-8, 9e-7)\r\n                )\r\n        self._target.add_instruction(CZGate(), cz_props)\r\n \r\n        cx_props = {}\r\n        # Add interchip 2q gates which are ecr (effectively CX)\r\n        # First determine which nodes to connect\r\n        node_indices = self._graph.node_indices()\r\n        edge_list = self._graph.edge_list()\r\n        inter_chip_nodes = {}\r\n        for node in node_indices:\r\n            count = 0\r\n            for edge in edge_list:\r\n                if node == edge[0]:\r\n                    count+=1\r\n            if count == 1:\r\n                inter_chip_nodes[node] = count\r\n        # Create inter-chip ecr props\r\n        cx_props = {}\r\n        inter_chip_edges = list(inter_chip_nodes.keys())\r\n        for i in range(1, number_of_chips):\r\n            offset = i * len(self._graph)\r\n            edge = (inter_chip_edges[1] + (len(self._graph) * (i-1)) , inter_chip_edges[0] + offset)\r\n            cx_props[edge] = InstructionProperties(\r\n                error=rng.uniform(7e-4, 5e-3), duration=rng.uniform(1e-8, 9e-7)\r\n            )\r\n \r\n        self._target.add_instruction(ECRGate(), cx_props)\r\n \r\n    @property\r\n    def target(self):\r\n        return self._target\r\n \r\n    @property\r\n    def max_circuits(self):\r\n        return None\r\n \r\n    @property\r\n    def graph(self):\r\n        return self._graph\r\n \r\n \r\n    @classmethod\r\n    def _default_options(cls):\r\n        return Options(shots=1024)\r\n \r\n    def run(self, circuit, **kwargs):\r\n        raise NotImplementedError(\"This backend does not contain a run method\")\r\n```\r\n" }
      },
      inputs: 1,
      outputs: 1,
      icon: "white_info.svg",
      label: function () {
        return this.name || "Create a Custom Backend";
      }
      
    });

  </script>
  
  <script type="text/html" data-template-name="create-custom-backend">
    <div class="form-row">
      <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
      <input type="text" id="node-input-name" placeholder="Create a Custom Backend" />
    </div>

  </script>

  
  
  <script type="text/html" data-help-name="create-custom-backend">
    <p>A node that create a custom backend.</p>

    <h3>Details</h3>
    <p>     
      This node provides an introduction to the FakeLOCCBackend, a simulated multi-chip quantum backend designed for educational and experimental purposes. The FakeLOCCBackend mimics a quantum computing environment with multiple chips, each featuring a heavy-hex coupling map. This backend includes a variety of quantum gate instructions, such as single-qubit gates (X, SX, RZ), measurement, and reset operations, as well as two-qubit gates (CZ and ECR). It serves as a useful tool for visualizing and understanding the concepts of quantum circuit transpilation and backend-specific attributes without executing actual quantum computations.
    </p>
  </script>
  