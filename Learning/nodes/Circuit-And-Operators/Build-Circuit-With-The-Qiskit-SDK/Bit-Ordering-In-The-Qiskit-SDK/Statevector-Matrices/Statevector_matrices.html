<script type="text/javascript">
  RED.nodes.registerType('State_vector_matrices', {
    category: 'Learning Bit ordering in the Qiskit SDK',
    color: '#3FADB5',
    defaults: {
      name: { value: "State vector matrices" },
      info: {
        value: "## **Node Input:**\r\n- # Object: `sv` (Type: _qiskit.quantum_info.Statevector_)\r\n\r\n***\r\n&nbsp;\r\n# When representing a statevector as a list of complex numbers (amplitudes), Qiskit orders these amplitudes such that the amplitude at index ùë• represents the computational basis state ‚à£ùë•‚ü©.\r\n&nbsp;\r\n# In the following code snippet, we will output the second and third elements of the statevector created in the previous node to examine the amplitudes of the basis states ‚à£01‚ü© and ‚à£10‚ü©.\r\n```python\r\nprint(sv[1])  # amplitude of state |01>\r\nprint(sv[2])  # amplitude of state |10>\r\n```\r\n# The Output is sent to \"Statevector matrices Output\" node and you can check them in the debug sidebar. Since qubit 0 of the statevector `sv` is in state ‚à£+‚ü© and qubit 1 is in state ‚à£0‚ü©, the amplitude of the basis state ‚à£01‚ü© should be 1 / sqrt(2), while the amplitude of the basis state ‚à£10‚ü© should be 0.\r\n\r\n***\r\n&nbsp;\r\n## **Node Output:**\r\n- # Object: `sv[1]`, `sv[2]` (Type: _numpy.complex128_)\r\n\r\n"
      }
    },
    inputs: 1,
    outputs: 1,
    icon: "file.svg",
    label: function () {
      return this.name || "State_vector_matrices";
    }
  });
</script>

<script type="text/html" data-template-name="State_vector_matrices">
  <div class="form-row">
      <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
      <input type="text" id="node-input-name" placeholder="Name">
  </div>
</script>

<script type="text/html" data-help-name="State_vector_matrices">
  <p>A node that introduce how qubits are ordered in quantum circuit diagram.</p>

  <h3>Inputs</h3>
  <ol class="node-ports">
    <li>State Vector
      <dl class="message-properties">
        <dt>sv<span class="property-type">qiskit.quantum_info.Statevector</span></dt>
        <dd>The state vector `sv` whose qubit 0 is in state ‚à£+‚ü©, and qubit 1 in state ‚à£0‚ü©.</dd>
      </dl>
    </li>
  </ol>

  <h3>Outputs</h3>
  <ol class="node-ports">
    <li>Complex number
      <dl class="message-properties">
        <dt>sv[1]<span class="property-type">numpy.complex128</span></dt>
        <dd>The complex number of state ‚à£01‚ü©.</dd>
      </dl>
    </li>
    <li>Complex number
      <dl class="message-properties">
        <dt>sv[2]<span class="property-type">numpy.complex128</span></dt>
        <dd>The complex number of state ‚à£10‚ü©.</dd>
      </dl>
    </li>
  </ol>

  <h3>Details</h3>
  <p>
    This node provides an introduction to how Qiskit represents statevectors in quantum computing. Specifically, it explains the ordering of amplitudes in a statevector where each amplitude corresponds to a computational basis state. In Qiskit, the index of an amplitude in the statevector array directly maps to the computational basis state ‚à£x‚ü©, with the value at index 1 representing the amplitude of the state ‚à£01‚ü© and the value at index 2 representing the amplitude of the state ‚à£10‚ü©. This helps users understand how to interpret the statevector and extract specific state amplitudes in quantum computations.
  </p>
</script>