[
    {
        "id": "e578a50eef98f3b1",
        "type": "image",
        "z": "b791b03d4eddc84d",
        "name": "",
        "width": "300",
        "data": "payload.result.circuit_image",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 860,
        "y": 40,
        "wires": []
    },
    {
        "id": "629d4186c5279bf1",
        "type": "inject",
        "z": "b791b03d4eddc84d",
        "name": "Start",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 110,
        "y": 160,
        "wires": [
            [
                "b32bf51e9740971b"
            ]
        ]
    },
    {
        "id": "e110a85e53d21d4a",
        "type": "debug",
        "z": "b791b03d4eddc84d",
        "name": "result",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload.result",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 930,
        "y": 460,
        "wires": []
    },
    {
        "id": "f30d4a6e9208c29b",
        "type": "estimator-run-options",
        "z": "b791b03d4eddc84d",
        "name": "Set Estimator run options",
        "info": "# [Exact simulation with Qiskit SDK primitives guide.](https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives#)\r\n&nbsp;\r\n# By default, the reference Estimator performs an exact statevector calculation based on the <font style='background: GhostWhite'>_`quantum_info.Statevector`_</font> class. However, this can be modified to introduce the effect of the sampling overhead (also known as \"shot noise\").\r\n# With the introduction of the new V2 interface, the sampling overhead in the Estimator is now more concretely defined. The new interface accepts a <font style='background: GhostWhite'>_`precision`_</font> argument that expresses the error bars that the primitive implementation should target for expectation values estimates, instead of the number of <font style='background: GhostWhite'>_`shots`_</font> used in the V1 interface.\r\n# StatevectorEstimator (V2)\r\nThe sampling overhead is now called <font style='background: GhostWhite'>_`precision`_</font>, and is defined exclusively at the <font style='background: GhostWhite'>_`.run()`_</font> method level. This allows for a more finely-grained tuning of the option all the way to the PUB level.\r\n This example assumes you have defined two circuits, each with its own array of observables.\r\n```python\r\n# Estimate expectation values for two PUBs, both with 0.05 precision.\r\nestimator.run([(isa_circuit1, isa_obs_array1), (isa_circuit2, isa_obs_array_2)], precision=0.05)\r\n```\r\n For a full example, see the [Primitives examples](https://docs.quantum.ibm.com/guides/primitives-examples#estimator-examples) page.\r\n# Estimator (V1)\r\nThe V1 interface specifies shots in the following ways:\r\n- Setting keyword arguments in the <font style='background: GhostWhite'>_`qiskit.primitives.Estimator.run`_</font> method.\r\n - Modifying the <font style='background: GhostWhite'>_`qiskit.primitives.Estimator `_</font> options.\r\nobject) with the <font style='background: GhostWhite'>_`JobV1.result`_</font> method. \r\n```python\r\njob = estimator.run(isa_circuit, isa_observable, shots=2048, seed=123)\r\nresult = job.result()\r\n```\r\n ",
        "x": 790,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "b32bf51e9740971b",
        "type": "intro-to-debug",
        "z": "b791b03d4eddc84d",
        "name": "Introduction to debugging tools",
        "info": "# [Introduction to debugging tools guide.](https://docs.quantum.ibm.com/guides/debugging-tools#)\r\n&nbsp;\r\n# Quantum programs can be tested by running them on simulated devices and exploring their performance under realistic device noise models. This allows you to debug them before sending them to a physical system. Quantum simulators can be used to help develop and test programs before fine-tuning them and sending them to quantum hardware.Local simulators can do this with good performance and efficiency.\r\n# However, due to the cost of classically simulating quantum circuits scales exponentially with the number of qubits, circuits that are larger than 50 qubits or so generally cannot run on simulators. For such circuits, you can test smaller versions of the circuits that can be simulated classically or you can modify the circuits so that they become classically simulable, although less accurate.",
        "x": 330,
        "y": 160,
        "wires": [
            [
                "1b2899f1a8bcbbc7"
            ]
        ]
    },
    {
        "id": "1b2899f1a8bcbbc7",
        "type": "qiskit-primatives",
        "z": "b791b03d4eddc84d",
        "name": "Qiskit SDK primatives",
        "info": "# [Exact simulation with Qiskit SDK primitives guide.](https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives#)\r\n&nbsp;\r\n# The reference primitives in the Qiskit SDK perform local statevector simulations. These simulations do not support modeling device noise, but are useful for quickly prototyping algorithms before looking into more advanced simulation techniques [using Qisker Aer](https://docs.quantum.ibm.com/guides/simulate-stabilizer-circuits) or running on real devices [Qiskit Runtime primitives](https://docs.quantum.ibm.com/guides/primitives).\r\n# The <font style='background: GhostWhite'>_`Estimator`_</font> primitive can compute expectation values of circuits, and the <font style='background: GhostWhite'>_`Sampler`_</font> primitive can sample from output distributions of circuits.",
        "x": 380,
        "y": 220,
        "wires": [
            [
                "a3f619a75dff6637"
            ]
        ]
    },
    {
        "id": "a3f619a75dff6637",
        "type": "use-reference-estimator",
        "z": "b791b03d4eddc84d",
        "name": "Use the rerference Estimator",
        "info": "# [Exact simulation with Qiskit SDK primitives guide.](https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives#)\r\n&nbsp;\r\n# There are two reference implementations of <font style='background: GhostWhite'>_`Estimator`_</font> in <font style='background: GhostWhite'>_`qiskit.primitives`_</font> that run on a local statevecotr simulators: the [StatevectorEstimator](https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.StatevectorEstimator) class andthe [Estimator](https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.Estimator) class. The  <font style='background: GhostWhite'>_`StatevectorEstimator`_</font> implements the new Estimator V2 interface introduced in the Qiskit SDK 1.0, and offers additional input vectorization features in comparison with the <font style='background: GhostWhite'>_`Estimator`_</font> class, which implements the legacy Estimator V1 interface. Both can take circuits, observables, and parameters as inputs and return the locally computed expectation values.\r\n# This node contains the code that prepares the inputs that will be used in the examples that follow and outputs the circuit.\r\n# Every code sample added in later nodes in the flow can be added directly below the previous code samples in your qiskit .\r\nfile or reordered for a cleaner look.\r\n# The expected input type for the observables is <font style='background: GhostWhite'>_`qiskit.quantum_info.SparsePauliOp.`_</font> Note that the circuit in the example is parametrized, but you can also run the Estimator on non-parametrized circuits. Also note that any circuit passed to an Estimator must not include any measurements.\r\n```python\r\nfrom qiskit import QuantumCircuit\r\nfrom qiskit.circuit import Parameter\r\nfrom qiskit.quantum_info import SparsePauliOp\r\nimport numpy as np\r\n\r\n# circuit for which you want to obtain the expected value\r\nqc = QuantumCircuit(2)\r\nqc.ry(Parameter('theta'), 0)\r\nqc.h(0)\r\nqc.cx(0,1)\r\nqc.draw(\"mpl\", style=\"iqp\")\r\n# observable(s) whose expected values you want to compute\r\nfrom qiskit.quantum_info import SparsePauliOp\r\nobservable = SparsePauliOp([\"II\", \"XX\", \"YY\", \"ZZ\"], coeffs=[1, 1, -1, 1])\r\n# value(s) for the circuit parameter(s)\r\nparameter_values = [[0], [np.pi/6], [np.pi/2]]\r\n```\r\n ",
        "x": 480,
        "y": 280,
        "wires": [
            [
                "e578a50eef98f3b1",
                "bf337f0a13ab6583"
            ]
        ]
    },
    {
        "id": "bf337f0a13ab6583",
        "type": "transpile-to-ISA",
        "z": "b791b03d4eddc84d",
        "name": "Transpile to ISA circuits and observables",
        "info": "# [Exact simulation with Qiskit SDK primitives guide.](https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives#)\r\n&nbsp;\r\n# The Qiskit Runtime primitives workflow requires circuits and observables to be transformed to only use instructions supported by the system (referred to as instruction set architecture (ISA) circuits and observables). The reference primitives still accept abstract instructions, as they rely on local statevectorsimulations, but transpiling the circuit might still be beneficial in terms of circuit optimization.\r\n```python\r\n# Generate a pass manager without providing a backend\r\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\r\n\r\npm = generate_preset_pass_manager(optimization_level=1)\r\nisa_circuit = pm.run(qc)\r\nisa_observable = observable.apply_layout(isa_circuit.layout)\r\n```\r\n ",
        "x": 600,
        "y": 340,
        "wires": [
            [
                "8696a083eba9758e"
            ]
        ]
    },
    {
        "id": "8696a083eba9758e",
        "type": "initialize-estimator",
        "z": "b791b03d4eddc84d",
        "name": "Initialize Estimator",
        "info": "# [Exact simulation with Qiskit SDK primitives guide.](https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives#)\r\n&nbsp;\r\n# To use the Estimator V2 implementation, follow the instructions to instantiate a <font style='background: GhostWhite'>_`qiskit.primitives.StatevectorEstimator`_</font>. If you want to maintain your pre-existing workflow using an Estimator V1 implementation, you can also use the <font style='background: GhostWhite'>_`qiskit.primitives.Estimator`_</font> class. \r\n# The nodes used in this flow use the Estimator V2 implementation, but each node will contain example code for both implementations.\r\n# StatevectorEstimator (V2)\r\nInstantiate a <font style='background: GhostWhite'>_`qiskit.primitives.StatevectorEstimator`_</font>\r\n```python\r\nfrom qiskit.primitives import StatevectorEstimator\r\nestimator = StatevectorEstimator()\r\n```\r\n # Estimator (V1)\r\nInstantiate a <font style='background: GhostWhite'>_`qiskit.primitives.Estimator`_</font>\r\n```python\r\nfrom qiskit.primitives import Estimator\r\nestimator = Estimator()\r\n```\r\n ",
        "x": 610,
        "y": 400,
        "wires": [
            [
                "199612259e17624c"
            ]
        ]
    },
    {
        "id": "199612259e17624c",
        "type": "run-estimator",
        "z": "b791b03d4eddc84d",
        "name": "Run the estimator",
        "info": "# [Exact simulation with Qiskit SDK primitives guide.](https://docs.quantum.ibm.com/guides/simulate-with-qiskit-sdk-primitives#)\r\n&nbsp;\r\n# To run the estimation and get results, more code has to be added. The example code used in this node only uses one circuit (of type <font style='background: GhostWhite'>_`QuantumCircuit`_</font> and one observable.\r\n# StatevectorEstimator (V2)\r\nRun the estimation by calling the <font style='background: GhostWhite'>_`StatevectorEstimator.run`_</font> method, which returns an instance of a <font style='background: GhostWhite'>_`PrimitiveJob`_</font> object. You can get the results from the job (as a <font style='background: GhostWhite'>_`qiskit.primitives.PrimitiveResult`_</font> object) with the <font style='background: GhostWhite'>_`qiskit.primitives.PrimitiveJob.result`_</font> method. \r\n```python\r\njob = estimator.run([(isa_circuit, isa_observable, parameter_values)])\r\nresult = job.result()\r\nprint(f\" > Result class: {type(result)}\")\r\n```\r\n # Estimator (V1)\r\nRun the estimation by calling the <font style='background: GhostWhite'>_`Estimator.run`_</font> method, which returns an instance of <font style='background: GhostWhite'>_`qiskit.providers.JobV1`_</font>. You can get the results from the job (as a <font style='background: GhostWhite'>_`EstimatorResult`_</font> object) with the <font style='background: GhostWhite'>_`JobV1.result`_</font> method. \r\n```python\r\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\r\nisa_circuit = pm.run(qc)\r\n\r\njob = estimator.run([isa_circuit]*3, [isa_observable]*3, parameter_values)\r\nresult = job.result()\r\nprint(f\" > Result class: {type(result)}\")\r\n```\r\n # Get the expected value from the result\r\n# StatevectorEstimator (V2)\r\nThe primitives V2 result outputs an array of <font style='background: GhostWhite'>_`PubResults`_</font>, where each item of the array is a PubResult object that contains in its data the array of evaluations corresponding to every circuit-observable combination in the PUB. To retrieve the expectation values and metadata for the first (and in this case, only) circuit evaluation, we must access the evaluation <font style='background: GhostWhite'>_`data`_</font> for PUB 0: \r\n```python\r\nprint(f\" > Expectation value: {result[0].data.evs}\")\r\nprint(f\" > Metadata: {result[0].metadata}\")\r\n```\r\n # Estimator (V1)\r\nThe primitives V1 result stores an array of values that can be accessed through the attribute <font style='background: GhostWhite'>_`EstimatorResult.values`_</font>, where the ith element is the expectation value corresponding to the ith circuit and ith observable. To see the values for the first (and in this case, only) circuit evaluation, we must access the first item of the array. \r\n```python\r\nprint(f\" > Expectation value: {result.values[0]}\")\r\nprint(f\" > Metadata: {result.metadata}\")\r\n```\r\n ",
        "x": 690,
        "y": 460,
        "wires": [
            [
                "e110a85e53d21d4a",
                "f30d4a6e9208c29b"
            ]
        ]
    }
]