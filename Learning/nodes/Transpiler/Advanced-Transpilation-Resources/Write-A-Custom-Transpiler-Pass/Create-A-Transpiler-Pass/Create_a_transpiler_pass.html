
<script type="text/javascript">
    RED.nodes.registerType("create-transpiler-pass", {
      category: "Learning Write a custom transpiler pass",
      color: "#dddddd",
      defaults: {
        name: { value: "Create a PauliTwirl transpiler pass" },
        info: { value: "# In our example, we will demonstrate how to construct a transpiler pass that adds Pauli twirls.\r\n&nbsp;\r\n# [Pauli twirling](https://arxiv.org/abs/quant-ph/0606161) is an error suppression strategy that randomizes how qubits experience noisy channels, which we assume to be two-qubit gates in this example (because they are much more error-prone than single-qubit gates). The Pauli twirls do not affect the two-qubit gates' operation. They are chosen such that those applied before the two-qubit gate (to the left) are countered by those applied after the two-qubit gate (to the right). In this sense, the two-qubit operations are identical, but the way they are performed is different. One benefit of Pauli twirling is that it turns coherent errors into stochastic errors, which can be improved by averaging more.\r\n&nbsp;\r\n# To create a PauliTwirl class, we first need to define '_init_' method for PauliTwirl object. If no specific gates are provided to twirl, it defaults to the CXGate and ECRGate. It then calls build_twirl_set() to prepare the set of Pauli operations.\r\n```python\r\nfrom qiskit.dagcircuit import DAGCircuit\r\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister, Gate\r\nfrom qiskit.circuit.library import CXGate, ECRGate\r\nfrom qiskit.transpiler import PassManager\r\nfrom qiskit.transpiler.basepasses import TransformationPass\r\nfrom qiskit.quantum_info import Operator, pauli_basis\r\n \r\nimport numpy as np\r\n \r\nfrom typing import Iterable, Optional\r\n\r\nclass PauliTwirl(TransformationPass):\r\n    \"\"\"Add Pauli twirls to two-qubit gates.\"\"\"\r\n \r\n    def __init__(\r\n        self,\r\n        gates_to_twirl: Optional[Iterable[Gate]] = None,\r\n    ):\r\n        \"\"\"\r\n        Args:\r\n            gates_to_twirl: Names of gates to twirl. The default behavior is to twirl all\r\n                two-qubit basis gates, `cx` and `ecr` for IBM backends.\r\n        \"\"\"\r\n        if gates_to_twirl is None:\r\n            gates_to_twirl = [CXGate(), ECRGate()]\r\n        self.gates_to_twirl = gates_to_twirl\r\n        self.build_twirl_set()\r\n        super().__init__()\r\n```\r\n&nbsp;\r\n# Transpiler passes act on the [DAG](https://docs.quantum.ibm.com/api/qiskit/qiskit.dagcircuit.DAGCircuit), so the important method to override is <font style=\"background: lightgrey\">.run()</font>, which takes the DAG as input. Initializing pairs of Paulis as shown preserves the operation of each two-qubit gate. This is done with the helper method <font style=\"background: lightgrey\">build_twirl_set</font>, which goes through each two-qubit Pauli (as obtained from <font style=\"background: lightgrey\">pauli_basis(2)</font>) and finds the other Pauli that preserves the operation.\r\n```python\r\n def build_twirl_set(self):\r\n        \"\"\"\r\n        Build a set of Paulis to twirl for each gate and store internally as .twirl_set.\r\n        \"\"\"\r\n        self.twirl_set = {}\r\n \r\n        # iterate through gates to be twirled\r\n        for twirl_gate in self.gates_to_twirl:\r\n            twirl_list = []\r\n \r\n            # iterate through Paulis on left of gate to twirl\r\n            for pauli_left in pauli_basis(2):\r\n \r\n                # iterature through Paulis on right of gate to twirl\r\n                for pauli_right in pauli_basis(2):\r\n \r\n                    # save pairs that produce identical operation as gate to twirl\r\n                    if (Operator(pauli_left) @ Operator(twirl_gate)).equiv(Operator(twirl_gate) @ pauli_right):\r\n                        twirl_list.append((pauli_left, pauli_right))\r\n \r\n            self.twirl_set[twirl_gate.name] = twirl_list\r\n```\r\n&nbsp;\r\n# Finally, we need to override <font style=\"background: lightgrey\">.run()</font> method. From the DAG, use the <font style=\"background: lightgrey\">op_nodes()</font> method to return all of its nodes. The DAG can also be used to collect runs, which are sequences of nodes that run uninterrupted on a qubit. These can be collected as single-qubit runs with <font style=\"background: lightgrey\">collect_1q_runs</font>, two-qubit runs with <font style=\"background: lightgrey\">collect_2q_runs</font>, and runs of nodes where the instruction names are in a namelist with <font style=\"background: lightgrey\">collect_runs</font>. The <font style=\"background: lightgrey\">DAGCircuit</font> has many methods for searching and traversing a graph. One commonly used method is <font style=\"background: lightgrey\">topological_op_nodes</font>, which provides the nodes in a dependency ordering. Other methods such as <font style=\"background: lightgrey\">bfs_successors</font> are used primarily to determine how nodes interact with subsequent operations on a DAG.\r\n&nbsp;\r\n# In the example, we want to replace each node, representing an instruction, with a subcircuit built as a mini DAG. The mini DAG has a two-qubit quantum register added to it. Operations are added to the mini DAG by using <font style=\"background: lightgrey\">apply_operation_back</font>, which places the <font style=\"background: lightgrey\">Instruction</font> on the mini DAG's output (whereas <font style=\"background: lightgrey\">apply_operation_front</font> would place it on the mini DAG's input). The node is then substituted by the mini DAG by using <font style=\"background: lightgrey\">substitute_node_with_dag</font>, and the process continues over each instance of <font style=\"background: lightgrey\">CXGate</font> and <font style=\"background: lightgrey\">ECRGate</font> in the DAG (corresponding to the two-qubit basis gates on IBMÂ® backends).\r\n```python\r\ndef run(\r\n        self,\r\n        dag: DAGCircuit,\r\n    ) -> DAGCircuit:\r\n \r\n        # collect all nodes in DAG and proceed if it is to be twirled\r\n        twirling_gate_classes = tuple(gate.base_class for gate in self.gates_to_twirl)\r\n        for node in dag.op_nodes():\r\n            if not isinstance(node.op, twirling_gate_classes):\r\n                continue\r\n \r\n            # random integer to select Pauli twirl pair\r\n            pidx = np.random.randint(0, len(self.twirl_set[node.op.name]),)\r\n            twirl_pair = self.twirl_set[node.op.name][pidx]\r\n \r\n            # instantiate mini_dag and attach quantum register\r\n            mini_dag = DAGCircuit()\r\n            register = QuantumRegister(2)\r\n            mini_dag.add_qreg(register)\r\n \r\n            # apply left Pauli, gate to twirl, and right Pauli to empty mini-DAG\r\n            mini_dag.apply_operation_back(twirl_pair[0].to_instruction(), [register[0], register[1]])\r\n            mini_dag.apply_operation_back(node.op, [register[0], register[1]])\r\n            mini_dag.apply_operation_back(twirl_pair[1].to_instruction(), [register[0], register[1]])\r\n \r\n            # substitute gate to twirl node with twirling mini-DAG\r\n            dag.substitute_node_with_dag(node, mini_dag)\r\n \r\n        return dag\r\n```\r\n# In the next node, we will show you how to use this <font style=\"background: lightgrey\">PauliTwirl</font> transpiler pass.\r\n" }
      },
      inputs: 1,
      outputs: 1,
      icon: "white_info.svg",
      label: function () {
        return this.name || "Create a PauliTwirl transpiler pass";
      },
      
    });

  </script>
  
  <script type="text/html" data-template-name="create-transpiler-pass">
    <div class="form-row">
      <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
      <input type="text" id="node-input-name" placeholder="Create a PauliTwirl transpiler pass" />
    </div>

  </script>

  
  
  <script type="text/html" data-help-name="create-transpiler-pass">
    <p>A node that create a PauliTwirl transpiler pass.</p>

    <h3>Details</h3>
    <p>     
      This node provides an introduction to the concept of Pauli twirling, a quantum error suppression technique used in quantum computing. Pauli twirling involves the application of Pauli operators before and after two-qubit gates, such as CXGate and ECRGate, to randomize how qubits experience noise. By converting coherent errors into stochastic errors, this technique enhances error resilience in quantum circuits. The node explains the key steps involved in constructing a Pauli twirling pass within a quantum circuit transpiler, focusing on how the Pauli operators are selected and applied without altering the logical outcome of the circuit.
    </p>
  </script>
  