<script type="text/javascript">
    RED.nodes.registerType("observable-pauli-basis", {
      category: "function",
      color: "#aaaaaa",
      defaults: {
        name: { value: "Pauli Basis from_operator" },
        info: {
          value: "# [Specify observables in the Pauli basis guide.](https://docs.quantum.ibm.com/guides/specify-observables-pauli#)\r\n" +
          "&nbsp;\r\n" +
          "# Alternatively, we could be interested in measuring system properties like the average magnetization by " +
          "counting the number of spins aligned in the *Z*-direction with the observable\r\n " +
          "# *O = <sup>1</sup>&frasl;<sub>n</sub> Σ<sub>i=1</sub> Z<sub>i</sub>* \r\n" +
          "# For observables that are not given in terms of Pauli operators but in a matrix for, we first have to " +
          "reformulate them in the Pauli basis in order to evaluate them on a quantum computer. We are always able to " +
          "find such a representation as the Pauli matrices form a basis for the Hermitian *2<sup>n</sup> X 2<sup>n</sup>* " +
          "matrices. We expand the observable *O* as \r\n" +
          "# O = Σ<sub>P∈{I,X,Y,Z}<sup>⊗n</sup></sub> Tr(OP)P,\r\n" +
          "# where the sum runs over all possible *n*-qubit Pauli terms and *Tr(⋅)* is the trace of a matrix, which acts " +
          "as inner product. You can implement this decomposition from a matrix to Pauli terms using the " +
          "<font style='background: GhostWhite'>_`SparsePauliOp.from_operator`_</font> method, like so: \r\n" +
          "```python\r\n" +
          "import numpy as np\r\n" + 
          "from qiskit.quantum_info import SparsePauliOp\r\n" +
          "\r\n" +
          "matrix = np.array([[-1, 0, 0.5, -1],\r\n" +
          "		   [0, 1, 1, 0.5],\r\n" +
          "		   [0.5, 1, -1, 0],\r\n" + 
          "		   [-1, 0.5, 0, 1]])\r\n" + 
          "\r\n" +
          "observable = SparsePauliOp.from_operator(matrix)\r\n" +
          "print(observable)  \r\n" +
          "```\r\n " +
          "# This means the matrix can be written as Pauli terms as " +
          "*O = - Z<sub>1</sub> + 0.5 X<sub>2</sub> + Y<sub>2</sub>Y<sub>1</sub>.*"
      }
      },
      inputs: 1,
      outputs: 1,
      icon: "file.svg",
      label: function () {
        return this.name || "observable-pauli-basis";
      },
    });
  </script>
  
  <script type="text/html" data-template-name="observable-pauli-basis">
    <div class="form-row">
      <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
      <input type="text" id="node-input-name" placeholder="Name" />
    </div>
  </script>
  
  <script type="text/html" data-help-name="observable-pauli-basis">
    <p>A node that gives further information into the SparsePauliOp class</p>

    <h3>Outputs</h3>
    <ol class="node-ports">
      <li>Addition PauliList
        <dl class="message-properties">
          <dt>payload.result.observable <span class="property-type">string</span></dt>
          <dd>A string representation of using the from_operator method</dd>
        </dl>
      </li>
    </ol>
  
    <h3>Details</h3>
    <p>
      This node demonstrates more ways to to specify observable in the Pauli Basis.
    </p>
  </script>
  